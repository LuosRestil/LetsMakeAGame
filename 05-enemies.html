<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Enemies - Let's Make A Game</title>
    <link rel="stylesheet" href="libs/prism.css" />
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <header>
      <div id="title">Let's Make A Game</div>
      <nav id="nav"></nav>
    </header>
    <article>
      <h1>Enemies</h1>
      <section>
        <p>
          Time to make some enemies! But first, a little bit of housekeeping. Our game is about to get a lot more involved. Up to this point, we've only had the player to worry about, but now we're going to have enemies, and then projectiles and collisions... We need to get a little more organized in preparation for this. We'll create a Game class to house all the logic of our game instead of keeping it all in our <code class="lang-markup">main.ts</code> file. This will have the added benefit of allowing us to pass references to our game to any of our game objects that may need to update a piece of game state.
        </p>
        <pre>
          <code class="lang-typescript">
            // main.ts
            import { Game } from "./Game";
            import "./style.css";

            const canvas = document.getElementById("game-canvas") as HTMLCanvasElement;
            canvas.width = 1280;
            canvas.height = 720;
            const ctx = canvas.getContext("2d") as CanvasRenderingContext2D;

            new Game(ctx).start();


            // Game.ts
            import { Player } from "./Player";

            export class Game {
              ctx: CanvasRenderingContext2D;
              lastTime: number = 0;
              player: Player;

              constructor(ctx: CanvasRenderingContext2D) {
                this.ctx = ctx;
                this.player = new Player(ctx);
              }

              start(): void {
                requestAnimationFrame(this.loop);
              }

              private loop = (ms: number): void => {
                requestAnimationFrame(this.loop);

                const dt = ms - this.lastTime;
                const dts = dt / 1000;
                this.lastTime = ms;

                this.update(dts);
                this.draw();
              }

              private update(dts: number): void {
                this.player.update(dts);
              }

              private draw(): void {
                this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
                this.player.draw();
              }
            }
          </code>
        </pre>
        <p>
          Notice that we're using an arrow function for the <code class="lang-typescript">loop</code> method. If we don't do this, <code class="lang-typescript">this</code> is going to be <code class="lang-typescript">undefined</code> inside the method because of the way <code class="lang-typescript">this</code> is scoped in callback functions in JavaScript. The arrow function ensures that <code class="lang-typescript">this</code> is bound to the class in which the function is defined.
        </p>
        <p>
          This brings us back to where we started in terms of game functionality, but now we're in a better position to expand. Time to create our <code class="lang-typescript">Enemy</code> class.
        </p>
        <pre>
          <code class="lang-typescript">
            import { Vec2 } from "./Vec2";
            import { screenWrap } from "./utils";

            export class Enemy {
              ctx: CanvasRenderingContext2D;
              radius: number = 75;
              pos: Vec2 = new Vec2(0, 0);
              vel: Vec2;
              minVel: number = 20;
              maxVel: number = 120;

              constructor(ctx: CanvasRenderingContext2D) {
                this.ctx = ctx;
                this.vel = Vec2.fromAngle(Math.random() * Math.PI * 2).scale(
                  Math.random() * (this.maxVel - this.minVel) + this.minVel
                );
              }

              update(dts: number): void {
                this.pos.add(Vec2.scale(this.vel, dts));
                screenWrap(this, this.ctx);
              }

              draw(): void {
                const ctx = this.ctx;
                ctx.fillStyle = 'limegreen';
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          </code>
        </pre>
        <p>
          This should look pretty familiar. We have position and velocity. We have an <code class="lang-typescript">update</code> method that adds our velocity, scaled by dts, to our position. (The enemies will have a constant, randomly selected velocity, so there's no need for acceleration here). We have a <code class="lang-typescript">draw</code> method to show our enemy on the canvas. (This drawing is very simple for the sake of brevity, I encourage you to make it your own. Or you can just copy the long version from GitHub).
        </p>
        <p>
          Take a look at how we're constructing our starting position and velocity. Our position is going to be (0, 0), the top left corner of the canvas. To get our velocity, we're going to create a unit vector from a random angle, then scale that vector to a random magnitude (within a min-max range). Because we are screen-wrapping, this will give us the appearance of our enemy being spawned at one of the four corners of the screen. We don't want to just spawn in a random location, because we might squash the player right out of the gate.
        </p>
        <p>
          Since both the player and the enemies have identical screen wrapping needs, this function has been factored out into a <code class="lang-markup">utils.ts</code> file that can be shared by both classes. The Player class will be update accordingly.
        </p>
        <pre>
          <code class="lang-typescript">
            import { Vec2 } from "./Vec2";

            export function screenWrap(
              gameObject: { pos: Vec2 },
              ctx: CanvasRenderingContext2D
            ): void {
              const canvas = ctx.canvas;
              if (gameObject.pos.x &gt; canvas.width) {
                gameObject.pos.x = 0;
              } else if (gameObject.pos.y &gt; canvas.height) {
                gameObject.pos.y = 0;
              }
              if (gameObject.pos.x &lt; 0) {
                gameObject.pos.x = canvas.width;
              } else if (gameObject.pos.y &lt; 0) {
                gameObject.pos.y = canvas.height;
              }
            }
          </code>
        </pre>
        <p>
          This is more or less exactly what we had before, just passing in arguments for the game object (defined as anything with a <code class="lang-typescript">pos</code>property), and the canvas context (so we can get the canvas dimensions for comparison with the object's current position).
        </p>
        <p>
          Let's get some enemies on the screen! In our Game class, we'll add an array of Enemy as a property, then create and fill that array in the constructor.
        </p>
        <pre>
          <code class="lang-typescript">
            export class Game {
              ctx: CanvasRenderingContext2D;
              lastTime: number = 0;
              player: Player;
              enemies: Enemy[];
            
              constructor(ctx: CanvasRenderingContext2D) {
                this.ctx = ctx;
                this.player = new Player(ctx);
                this.enemies = this.spawnEnemies();
              }

              // ...

              private spawnEnemies(): Enemy[] {
                let enemies = [];
                for (let i = 0; i &lt; 3; i++) {
                  enemies.push(new Enemy(this.ctx));
                }
                return enemies;
              }
            }
          </code>
        </pre>
        <p>
          Then we'll update and draw the enemies alongside the player.
        </p>
        <pre>
          <code class="lang-typescript">
            private update(dts: number): void {
              this.player.update(dts);
              for (let enemy of this.enemies) {
                enemy.update(dts);
              }
            }
          
            private draw(): void {
              this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
              this.player.draw();
              for (let enemy of this.enemies) {
                enemy.draw();
              }
            }
          </code>
        </pre>
        <video muted controls>
          <source src="vid/05-enemies/enemies.mp4" type="video/mp4" />
          Your browser does not support the video tag.
        </video>
        <p>
          And that's it! We have enemies on screen. This was pretty easy for us to implement due to the groundwork that we laid with vectors. In the next section, we'll start firing projectiles.
        </p>
        <a href="04-player-control.html">Previous</a>
        <!-- <a href="06-projectiles.html">Next</a> -->
      </section>
    </article>
    <script src="libs/prism.js"></script>
  </body>
</html>